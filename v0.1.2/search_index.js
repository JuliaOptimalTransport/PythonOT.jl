var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Exact-optimal-transport","page":"API","title":"Exact optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"emd\nemd2","category":"page"},{"location":"api/#PythonOT.emd","page":"API","title":"PythonOT.emd","text":"emd(μ, ν, C; kwargs...)\n\nCompute the optimal transport plan for the Monge-Kantorovich problem with source and target marginals μ and ν and cost matrix C of size (length(μ), length(ν)).\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n\nThis function is a wrapper of the function emd in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> emd(μ, ν, C)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.3\n\nSee also: emd2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.emd2","page":"API","title":"PythonOT.emd2","text":"emd2(μ, ν, C; kwargs...)\n\nCompute the optimal transport cost for the Monge-Kantorovich problem with source and target marginals μ and ν and cost matrix C of size (length(μ), length(ν)).\n\nThe optimal transport cost is the scalar value\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n\nThis function is a wrapper of the function emd2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> emd2(μ, ν, C)\n0.95\n\nSee also: emd\n\n\n\n\n\n","category":"function"},{"location":"api/#Regularized-optimal-transport","page":"API","title":"Regularized optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sinkhorn\nsinkhorn2\nbarycenter","category":"page"},{"location":"api/#PythonOT.sinkhorn","page":"API","title":"PythonOT.sinkhorn","text":"sinkhorn(μ, ν, C, ε; kwargs...)\n\nCompute the optimal transport plan for the entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and entropic regularization parameter ε.\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term.\n\nThis function is a wrapper of the function sinkhorn in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> sinkhorn(μ, ν, C, 0.01)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.3\n\nIt is possible to provide multiple target marginals as columns of a matrix. In this case the optimal transport costs are returned:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn(μ, ν, C, 0.01); sigdigits=6)\n2-element Vector{Float64}:\n 0.95\n 0.45\n\nSee also: sinkhorn2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.sinkhorn2","page":"API","title":"PythonOT.sinkhorn2","text":"sinkhorn2(μ, ν, C, ε; kwargs...)\n\nCompute the optimal transport cost for the entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and entropic regularization parameter ε.\n\nThe optimal transport cost is the scalar value\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term.\n\nThis function is a wrapper of the function sinkhorn2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> round.(sinkhorn2(μ, ν, C, 0.01); sigdigits=6)\n1-element Vector{Float64}:\n 0.95\n\nIt is possible to provide multiple target marginals as columns of a matrix.\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn2(μ, ν, C, 0.01); sigdigits=6)\n2-element Vector{Float64}:\n 0.95\n 0.45\n\nSee also: sinkhorn\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.barycenter","page":"API","title":"PythonOT.barycenter","text":"barycenter(A, C, ε; kwargs...)\n\nCompute the entropically regularized Wasserstein barycenter with histograms A, cost matrix C, and entropic regularization parameter ε.\n\nThe Wasserstein barycenter is a histogram and solves\n\ninf_a sum_i W_varepsilonC(a a_i)\n\nwhere the histograms a_i are columns of matrix A and W_varepsilonC(a a_i) is the optimal transport cost for the entropically regularized optimal transport problem with marginals a and a_i, cost matrix C, and entropic regularization parameter varepsilon. Optionally, weights of the histograms a_i can be provided with the keyword argument weights.\n\nThis function is a wrapper of the function barycenter in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> A = rand(10, 3);\n\njulia> A ./= sum(A; dims=1);\n\njulia> C = rand(10, 10);\n\njulia> isapprox(sum(barycenter(A, C, 0.01; method=\"sinkhorn_stabilized\")), 1; atol=1e-4)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The submodule Smooth contains a function for solving regularized optimal transport problems with L2- and entropic regularization using the dual formulation. You can load the submodule with","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PythonOT.Smooth","category":"page"},{"location":"api/","page":"API","title":"API","text":"PythonOT.Smooth.smooth_ot_dual","category":"page"},{"location":"api/#PythonOT.Smooth.smooth_ot_dual","page":"API","title":"PythonOT.Smooth.smooth_ot_dual","text":"smooth_ot_dual(μ, ν, C, ε; reg_type=\"l2\", kwargs...)\n\nCompute the optimal transport plan for a regularized optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and regularization parameter ε.\n\nThe optimal transport map γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) is the L2-regularization term Omega(gamma) = gamma_F^22 if reg_type=\"l2\" (the default) or the entropic regularization term Omega(gamma) = sum_ij gamma_ij log gamma_ij if reg_type=\"kl\".\n\nThe function solves the dual formulation[BSR2018]\n\nmax_alpha beta mu^mathsfT alpha + nu^mathsfT beta \nsum_j delta_Omega(alpha + beta_j - C_j)\n\nwhere C_j is the jth column of the cost matrix and delta_Omega is the conjugate of the regularization term Omega.\n\nThis function is a wrapper of the function smooth_ot_dual in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> smooth_ot_dual(μ, ν, C, 0.01)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.300001\n\n[BSR2018]: Blondel, M., Seguy, V., & Rolet, A. (2018). Smooth and Sparse Optimal Transport. In Proceedings of the Twenty-First International Conference on Artificial Intelligence and Statistics (AISTATS).\n\n\n\n\n\n","category":"function"},{"location":"api/#Unbalanced-optimal-transport","page":"API","title":"Unbalanced optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sinkhorn_unbalanced\nsinkhorn_unbalanced2\nbarycenter_unbalanced","category":"page"},{"location":"api/#PythonOT.sinkhorn_unbalanced","page":"API","title":"PythonOT.sinkhorn_unbalanced","text":"sinkhorn_unbalanced(μ, ν, C, ε, λ; kwargs...)\n\nCompute the optimal transport plan for the unbalanced entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), entropic regularization parameter ε, and marginal relaxation term λ.\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma langle gamma C rangle\n+ varepsilon Omega(gamma)\n+ lambda mathrmKL(gamma 1 mu)\n+ lambda mathrmKL(gamma^mathsfT 1 nu)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term and mathrmKL is the Kullback-Leibler divergence.\n\nThis function is a wrapper of the function sinkhorn_unbalanced in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> sinkhorn_unbalanced(μ, ν, C, 0.01, 1_000)\n3×2 Matrix{Float64}:\n 0.0  0.499964\n 0.0  0.200188\n 0.0  0.29983\n\nIt is possible to provide multiple target marginals as columns of a matrix. In this case the optimal transport costs are returned:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn_unbalanced(μ, ν, C, 0.01, 1_000); sigdigits=6)\n2-element Vector{Float64}:\n 0.949709\n 0.449411\n\nSee also: sinkhorn_unbalanced2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.sinkhorn_unbalanced2","page":"API","title":"PythonOT.sinkhorn_unbalanced2","text":"sinkhorn_unbalanced2(μ, ν, C, ε, λ; kwargs...)\n\nCompute the optimal transport cost for the unbalanced entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), entropic regularization parameter ε, and marginal relaxation term λ.\n\nThe optimal transport cost is the scalar value\n\ninf_gamma langle gamma C rangle\n+ varepsilon Omega(gamma)\n+ lambda mathrmKL(gamma 1 mu)\n+ lambda mathrmKL(gamma^mathsfT 1 nu)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term and mathrmKL is the Kullback-Leibler divergence.\n\nThis function is a wrapper of the function sinkhorn_unbalanced2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> round.(sinkhorn_unbalanced2(μ, ν, C, 0.01, 1_000); sigdigits=6)\n1-element Vector{Float64}:\n 0.949709\n\nIt is possible to provide multiple target marginals as columns of a matrix:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn_unbalanced2(μ, ν, C, 0.01, 1_000); sigdigits=6)\n2-element Vector{Float64}:\n 0.949709\n 0.449411\n\nSee also: sinkhorn_unbalanced\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.barycenter_unbalanced","page":"API","title":"PythonOT.barycenter_unbalanced","text":"barycenter_unbalanced(A, C, ε, λ; kwargs...)\n\nCompute the entropically regularized unbalanced Wasserstein barycenter with histograms A, cost matrix C, entropic regularization parameter ε and marginal relaxation parameter λ.\n\nThe Wasserstein barycenter is a histogram and solves\n\ninf_a sum_i W_varepsilonClambda(a a_i)\n\nwhere the histograms a_i are columns of matrix A and W_varepsilonClambda(a a_i) is the optimal transport cost for the entropically regularized optimal transport problem with marginals a and a_i, cost matrix C, entropic regularization parameter varepsilon and marginal relaxation parameter lambda. Optionally, weights of the histograms a_i can be provided with the keyword argument weights.\n\nThis function is a wrapper of the function barycenter_unbalanced in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> A = rand(10, 3);\n\njulia> A ./= sum(A; dims=1);\n\njulia> C = rand(10, 10);\n\njulia> isapprox(sum(barycenter_unbalanced(A, C, 0.01, 1; method=\"sinkhorn_stabilized\")), 1; atol=1e-4)\nfalse\n\njulia> isapprox(sum(barycenter_unbalanced(\n           A, C, 0.01, 10_000; method=\"sinkhorn_stabilized\", numItermax=5_000\n       )), 1; atol=1e-4)\ntrue\n\nSee also: barycenter\n\n\n\n\n\n","category":"function"},{"location":"#PythonOT.jl","page":"Home","title":"PythonOT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia interface for the Python Optimal Transport (POT) package","category":"page"}]
}
