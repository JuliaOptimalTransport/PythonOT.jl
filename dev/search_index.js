var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Exact-optimal-transport","page":"API","title":"Exact optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"emd\nemd2\nemd_1d\nemd2_1d","category":"page"},{"location":"api/#PythonOT.emd","page":"API","title":"PythonOT.emd","text":"emd(μ, ν, C; kwargs...)\n\nCompute the optimal transport plan for the Monge-Kantorovich problem with source and target marginals μ and ν and cost matrix C of size (length(μ), length(ν)).\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n\nThis function is a wrapper of the function emd in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> emd(μ, ν, C)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.3\n\nSee also: emd2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.emd2","page":"API","title":"PythonOT.emd2","text":"emd2(μ, ν, C; kwargs...)\n\nCompute the optimal transport cost for the Monge-Kantorovich problem with source and target marginals μ and ν and cost matrix C of size (length(μ), length(ν)).\n\nThe optimal transport cost is the scalar value\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n\nThis function is a wrapper of the function emd2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> emd2(μ, ν, C)\n0.95\n\nSee also: emd\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.emd_1d","page":"API","title":"PythonOT.emd_1d","text":"emd_1d(xsource, xtarget; kwargs...)\n\nCompute the optimal transport plan for the Monge-Kantorovich problem with univariate discrete measures with support xsource and xtarget as source and target marginals.\n\nThis function is a wrapper of the function emd_1d in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> xsource = [0.2, 0.5];\n\njulia> xtarget = [0.8, 0.3];\n\njulia> emd_1d(xsource, xtarget)\n2×2 Matrix{Float64}:\n 0.0  0.5\n 0.5  0.0\n\njulia> histogram_source = [0.8, 0.2];\n\njulia> histogram_target = [0.7, 0.3];\n\njulia> emd_1d(xsource, xtarget; a=histogram_source, b=histogram_target)\n2×2 Matrix{Float64}:\n 0.5  0.3\n 0.2  0.0\n\nSee also: emd, emd2_1d\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.emd2_1d","page":"API","title":"PythonOT.emd2_1d","text":"emd2_1d(xsource, xtarget; kwargs...)\n\nCompute the optimal transport cost for the Monge-Kantorovich problem with univariate discrete measures with support xsource and xtarget as source and target marginals.\n\nThis function is a wrapper of the function emd2_1d in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> xsource = [0.2, 0.5];\n\njulia> xtarget = [0.8, 0.3];\n\njulia> round(emd2_1d(xsource, xtarget); sigdigits=6)\n0.05\n\njulia> histogram_source = [0.8, 0.2];\n\njulia> histogram_target = [0.7, 0.3];\n\njulia> round(emd2_1d(xsource, xtarget; a=histogram_source, b=histogram_target); sigdigits=6)\n0.201\n\nSee also: emd2, emd2_1d\n\n\n\n\n\n","category":"function"},{"location":"api/#Regularized-optimal-transport","page":"API","title":"Regularized optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sinkhorn\nsinkhorn2\nempirical_sinkhorn_divergence\nbarycenter","category":"page"},{"location":"api/#PythonOT.sinkhorn","page":"API","title":"PythonOT.sinkhorn","text":"sinkhorn(μ, ν, C, ε; kwargs...)\n\nCompute the optimal transport plan for the entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and entropic regularization parameter ε.\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term.\n\nThis function is a wrapper of the function sinkhorn in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> sinkhorn(μ, ν, C, 0.01)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.3\n\nIt is possible to provide multiple target marginals as columns of a matrix. In this case the optimal transport costs are returned:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn(μ, ν, C, 0.01); sigdigits=6)\n2-element Vector{Float64}:\n 0.95\n 0.45\n\nSee also: sinkhorn2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.sinkhorn2","page":"API","title":"PythonOT.sinkhorn2","text":"sinkhorn2(μ, ν, C, ε; kwargs...)\n\nCompute the optimal transport cost for the entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and entropic regularization parameter ε.\n\nThe optimal transport cost is the scalar value\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term.\n\nThis function is a wrapper of the function sinkhorn2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> round(sinkhorn2(μ, ν, C, 0.01); sigdigits=6)\n0.95\n\nIt is possible to provide multiple target marginals as columns of a matrix.\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn2(μ, ν, C, 0.01); sigdigits=6)\n2-element Vector{Float64}:\n 0.95\n 0.45\n\nSee also: sinkhorn\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.empirical_sinkhorn_divergence","page":"API","title":"PythonOT.empirical_sinkhorn_divergence","text":"empirical_sinkhorn_divergence(xsource, xtarget, ε; kwargs...)\n\nCompute the Sinkhorn divergence from empirical data, where xsource and xtarget are arrays representing samples in the source domain and target domain, respectively, and  ε is the regularization term.\n\nThis function is a wrapper of the function ot.bregman.empirical_sinkhorn_divergence in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> xsource = [1.0];\n\njulia> xtarget = [2.0, 3.0];\n\njulia> ε = 0.01;\n\njulia> empirical_sinkhorn_divergence(xsource, xtarget, ε) ≈\n       sinkhorn2([1], [0.5, 0.5], [1.0 4.0], ε) -\n       (\n           sinkhorn2([1], [1], zeros(1, 1), ε) +\n           sinkhorn2([0.5, 0.5], [0.5, 0.5], Float64[0 1; 1 0], ε)\n       ) / 2\ntrue\n\nSee also: sinkhorn2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.barycenter","page":"API","title":"PythonOT.barycenter","text":"barycenter(A, C, ε; kwargs...)\n\nCompute the entropically regularized Wasserstein barycenter with histograms A, cost matrix C, and entropic regularization parameter ε.\n\nThe Wasserstein barycenter is a histogram and solves\n\ninf_a sum_i W_varepsilonC(a a_i)\n\nwhere the histograms a_i are columns of matrix A and W_varepsilonC(a a_i) is the optimal transport cost for the entropically regularized optimal transport problem with marginals a and a_i, cost matrix C, and entropic regularization parameter varepsilon. Optionally, weights of the histograms a_i can be provided with the keyword argument weights.\n\nThis function is a wrapper of the function barycenter in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> A = rand(10, 3);\n\njulia> A ./= sum(A; dims=1);\n\njulia> C = rand(10, 10);\n\njulia> isapprox(sum(barycenter(A, C, 0.01; method=\"sinkhorn_stabilized\")), 1; atol=1e-4)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The submodule Smooth contains a function for solving regularized optimal transport problems with L2- and entropic regularization using the dual formulation. You can load the submodule with","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PythonOT.Smooth","category":"page"},{"location":"api/","page":"API","title":"API","text":"PythonOT.Smooth.smooth_ot_dual","category":"page"},{"location":"api/#PythonOT.Smooth.smooth_ot_dual","page":"API","title":"PythonOT.Smooth.smooth_ot_dual","text":"smooth_ot_dual(μ, ν, C, ε; reg_type=\"l2\", kwargs...)\n\nCompute the optimal transport plan for a regularized optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), and regularization parameter ε.\n\nThe optimal transport map γ is of the same size as C and solves\n\ninf_gamma in Pi(mu nu) langle gamma C rangle\n+ varepsilon Omega(gamma)\n\nwhere Omega(gamma) is the L2-regularization term Omega(gamma) = gamma_F^22 if reg_type=\"l2\" (the default) or the entropic regularization term Omega(gamma) = sum_ij gamma_ij log gamma_ij if reg_type=\"kl\".\n\nThe function solves the dual formulation[BSR2018]\n\nmax_alpha beta mu^mathsfT alpha + nu^mathsfT beta \nsum_j delta_Omega(alpha + beta_j - C_j)\n\nwhere C_j is the jth column of the cost matrix and delta_Omega is the conjugate of the regularization term Omega.\n\nThis function is a wrapper of the function smooth_ot_dual in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> smooth_ot_dual(μ, ν, C, 0.01)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2\n 0.0  0.300001\n\n[BSR2018]: Blondel, M., Seguy, V., & Rolet, A. (2018). Smooth and Sparse Optimal Transport. In Proceedings of the Twenty-First International Conference on Artificial Intelligence and Statistics (AISTATS).\n\n\n\n\n\n","category":"function"},{"location":"api/#Unbalanced-optimal-transport","page":"API","title":"Unbalanced optimal transport","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sinkhorn_unbalanced\nsinkhorn_unbalanced2\nbarycenter_unbalanced\nmm_unbalanced","category":"page"},{"location":"api/#PythonOT.sinkhorn_unbalanced","page":"API","title":"PythonOT.sinkhorn_unbalanced","text":"sinkhorn_unbalanced(μ, ν, C, ε, λ; kwargs...)\n\nCompute the optimal transport plan for the unbalanced entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), entropic regularization parameter ε, and marginal relaxation term λ.\n\nThe optimal transport plan γ is of the same size as C and solves\n\ninf_gamma langle gamma C rangle\n+ varepsilon Omega(gamma)\n+ lambda mathrmKL(gamma 1 mu)\n+ lambda mathrmKL(gamma^mathsfT 1 nu)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term and mathrmKL is the Kullback-Leibler divergence.\n\nThis function is a wrapper of the function sinkhorn_unbalanced in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> round.(sinkhorn_unbalanced(μ, ν, C, 0.01, 1_000); sigdigits=4)\n3×2 Matrix{Float64}:\n 0.0  0.5\n 0.0  0.2002\n 0.0  0.2998\n\nIt is possible to provide multiple target marginals as columns of a matrix. In this case the optimal transport costs are returned:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn_unbalanced(μ, ν, C, 0.01, 1_000); sigdigits=4)\n2-element Vector{Float64}:\n 0.9497\n 0.4494\n\nSee also: sinkhorn_unbalanced2\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.sinkhorn_unbalanced2","page":"API","title":"PythonOT.sinkhorn_unbalanced2","text":"sinkhorn_unbalanced2(μ, ν, C, ε, λ; kwargs...)\n\nCompute the optimal transport cost for the unbalanced entropic regularization optimal transport problem with source and target marginals μ and ν, cost matrix C of size (length(μ), length(ν)), entropic regularization parameter ε, and marginal relaxation term λ.\n\nThe optimal transport cost is the scalar value\n\ninf_gamma langle gamma C rangle\n+ varepsilon Omega(gamma)\n+ lambda mathrmKL(gamma 1 mu)\n+ lambda mathrmKL(gamma^mathsfT 1 nu)\n\nwhere Omega(gamma) = sum_ij gamma_ij log gamma_ij is the entropic regularization term and mathrmKL is the Kullback-Leibler divergence.\n\nThis function is a wrapper of the function sinkhorn_unbalanced2 in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> μ = [0.5, 0.2, 0.3];\n\njulia> ν = [0.0, 1.0];\n\njulia> C = [0.0 1.0; 2.0 0.0; 0.5 1.5];\n\njulia> round.(sinkhorn_unbalanced2(μ, ν, C, 0.01, 1_000); sigdigits=4)\n0.9497\n\nIt is possible to provide multiple target marginals as columns of a matrix:\n\njulia> ν = [0.0 0.5; 1.0 0.5];\n\njulia> round.(sinkhorn_unbalanced2(μ, ν, C, 0.01, 1_000); sigdigits=4)\n2-element Vector{Float64}:\n 0.9497\n 0.4494\n\nSee also: sinkhorn_unbalanced\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.barycenter_unbalanced","page":"API","title":"PythonOT.barycenter_unbalanced","text":"barycenter_unbalanced(A, C, ε, λ; kwargs...)\n\nCompute the entropically regularized unbalanced Wasserstein barycenter with histograms A, cost matrix C, entropic regularization parameter ε and marginal relaxation parameter λ.\n\nThe Wasserstein barycenter is a histogram and solves\n\ninf_a sum_i W_varepsilonClambda(a a_i)\n\nwhere the histograms a_i are columns of matrix A and W_varepsilonClambda(a a_i) is the optimal transport cost for the entropically regularized optimal transport problem with marginals a and a_i, cost matrix C, entropic regularization parameter varepsilon and marginal relaxation parameter lambda. Optionally, weights of the histograms a_i can be provided with the keyword argument weights.\n\nThis function is a wrapper of the function barycenter_unbalanced in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> A = rand(10, 3);\n\njulia> A ./= sum(A; dims=1);\n\njulia> C = rand(10, 10);\n\njulia> isapprox(sum(barycenter_unbalanced(A, C, 0.01, 1; method=\"sinkhorn_stabilized\")), 1; atol=1e-4)\nfalse\n\njulia> isapprox(sum(barycenter_unbalanced(\n           A, C, 0.01, 10_000; method=\"sinkhorn_stabilized\", numItermax=5_000\n       )), 1; atol=1e-4)\ntrue\n\nSee also: barycenter\n\n\n\n\n\n","category":"function"},{"location":"api/#PythonOT.mm_unbalanced","page":"API","title":"PythonOT.mm_unbalanced","text":"mm_unbalanced(a, b, M, reg_m; reg=0, c=a*b', kwargs...)\n\nSolve the unbalanced optimal transport problem and return the OT plan. The function solves the following optimization problem:\n\nW = min_gamma geq 0 langle gamma M rangle_F +\n    mathrmreg_m1 cdot operatornamediv(gamma mathbf1 a) +\n    mathrmreg_m2 cdot operatornamediv(gamma^mathsfT mathbf1 b) +\n    mathrmreg cdot operatornamediv(gamma c)\n\nwhere\n\nM is the metric cost matrix,\na and b are source and target unbalanced distributions,\nc is a reference distribution for the regularization,\nreg_m is the marginal relaxation term (if it is a scalar or an indexable object of length 1, then the same term is applied to both marginal relaxations), and\nreg is a regularization term.\n\nThis function is a wrapper of the function mm_unbalanced in the Python Optimal Transport package. Keyword arguments are listed in the documentation of the Python function.\n\nExamples\n\njulia> a=[.5, .5];\n\njulia> b=[.5, .5];\n\njulia> M=[1. 36.; 9. 4.];\n\njulia> round.(mm_unbalanced(a, b, M, 5, div=\"kl\"), digits=2)\n2×2 Matrix{Float64}:\n 0.45  0.0\n 0.0   0.34\n\njulia> round.(mm_unbalanced(a, b, M, 5, div=\"l2\"), digits=2)\n2×2 Matrix{Float64}:\n 0.4  0.0\n 0.0  0.1\n\n\n\n\n\n","category":"function"},{"location":"#PythonOT.jl","page":"Home","title":"PythonOT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia interface for the Python Optimal Transport (POT) package","category":"page"}]
}
